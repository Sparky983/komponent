import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromStream
import java.io.File
import java.io.FileWriter
import kotlin.collections.iterator

@Serializable
data class Tags(
    val tags: Map<String, Tag>,
    val global: Global
)

@Serializable
data class Global(
    val attributes: Map<String, Attribute>,
    val events: Map<String, Event>
)

@Serializable
data class Tag(
    val attributes: Map<String, Attribute> = mapOf(),
    val events: Map<String, Event> = mapOf(),
    val void: Boolean = false
)

@Serializable
data class Attribute(
    val parameter: String? = null,
    val type: String = "String",
    val required: Boolean = false
)

@Serializable
data class Event(
    val parameter: String? = null,
    val type: String = "Event"
) {
    fun parameter(forName: String) =
        "on" + (parameter ?: forName).replaceFirstChar { it.uppercase() }
}

@OptIn(ExperimentalSerializationApi::class)
fun generate(folder: File) {
    folder.mkdirs()
    val tagsApi = folder.resolve("tags.kt")
    tagsApi.createNewFile()

    val json = Tags::class.java.classLoader.getResourceAsStream("tags.json5")!!
    val format = Json {
        allowComments = true
        isLenient = true
    }
    val tagsDefinition = format.decodeFromStream<Tags>(json)

    val file = buildString {
        append(
            """
            // Generated by me/sparky983/komponent/generate.kt
            
            @file:Suppress("PackageDirectoryMismatch")
            
            package me.sparky983.komponent
    
            import kotlinx.browser.document
            import org.w3c.dom.events.*
            import org.w3c.dom.*
            
            private typealias EventHandler<E> = (E) -> Unit
            
            @PublishedApi
            internal fun element(
                name: String,
                attributes: Map<String, Signal<String?>>,
                events: Map<String, EventHandler<*>?>,
                vararg children: Element
            ): Element {
                val backing = document.createElement(name)
                val element = DomElement(backing)
                for ((attribute, signal) in attributes) {
                    signal.subscribe {
                        if (it == null) {
                            backing.removeAttribute(attribute)
                        } else {
                            backing.setAttribute(attribute, it)
                        }
                    }
                }
                for ((event, handler) in events) {
                    if (handler != null) {
                        backing.addEventListener(
                            event,
                            handler.unsafeCast<(Event) -> Unit>()
                        )
                    }
                }
                for (child in children) {
                    child.nodes().forEach(backing::appendChild)
                }
                return element
            }
            """.trimIndent()
        )

        val global = tagsDefinition.global

        for ((name, tag) in tagsDefinition.tags) {
            append("\n\n")
            append("""@Suppress("unused")""")
            append("\n")
            append("@Component\n")
            append("public fun ${name}(")

            val attributes = global.attributes + tag.attributes

            for ((name, attribute) in attributes) {
                val (parameter, type, isRequired) = attribute

                append("\n    ${parameter ?: name}: Signal<$type>")
                if (!isRequired) {
                    append("? = null")
                }
                append(",")
            }

            val events = global.events + tag.events

            for ((name, event) in events) {
                append("\n")
                append("    ")
                append(event.parameter(name))
                append(": EventHandler<${event.type}>? = null,")
            }

            if (!tag.void) {
                append("\n    vararg children: Element")
            }

            append("\n")
            append("): Element {\n")
            append("    return element(\n")
            append("        \"$name\",\n")
            append("        buildMap {")

            for ((name, attribute) in attributes) {
                val type = attribute.type
                val parameter = attribute.parameter ?: name

                append("\n")
                append("            ")

                if (attribute.required) {
                    append("put(\"$name\", ")
                } else {
                    append(parameter)
                    append("?.let { put(\"$name\", ")
                }

                append(parameter)

                when (type) {
                    "Boolean" -> {
                        append(" { if (it) \"\" else null }")
                    }

                    else -> {
                        if (type != "String") {
                            append("(Any::toString)")
                        }
                    }
                }

                append(")")

                if (!attribute.required) {
                    append(" }")
                }
            }

            append("\n")
            append("        },\n")
            append("        mapOf(")

            for ((name, event) in events) {
                append("\n")
                append("            \"$name\" to ${event.parameter(name)}, ")
            }

            append("\n")
            append("        )")

            if (!tag.void) {
                append(",\n")
                append("        children = children")
                append("\n")
                append("    )")
            } else {
                append("\n    )")
            }

            append("\n}")
        }
    }

    FileWriter(tagsApi).use {
        // Technically this is inefficient
        it.append(file.replace("\n", System.lineSeparator()))
    }
}