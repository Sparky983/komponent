import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromStream
import java.io.File
import java.io.FileWriter
import kotlin.collections.iterator

@Serializable
data class Tags(
    val tags: Map<String, Tag>,
    val global: Global
)

@Serializable
data class Global(
    val attributes: Map<String, Attribute>,
    val events: Map<String, Event>
)

@Serializable
data class Tag(
    val type: String = "HTMLElement",
    val ns: String? = null,
    val attributes: Map<String, Attribute> = mapOf(),
    val events: Map<String, Event> = mapOf(),
    val void: Boolean = false
)

@Serializable
data class Attribute(
    val parameter: String? = null,
    val type: String = "String",
    val required: Boolean = false
)

@Serializable
data class Event(
    val parameter: String? = null,
    val type: String = "Event"
) {
    fun parameter(forName: String) =
        "on" + (parameter ?: forName).replaceFirstChar { it.uppercase() }
}

@OptIn(ExperimentalSerializationApi::class)
fun generate(folder: File) {
    folder.mkdirs()
    val tagsApi = folder.resolve("tags.kt")
    tagsApi.createNewFile()

    val json = Tags::class.java.classLoader.getResourceAsStream("tags.json5")!!
    val format = Json {
        allowComments = true
        isLenient = true
    }
    val tagsDefinition = format.decodeFromStream<Tags>(json)

    val file = buildString {
        append(
            """
            // Generated by me/sparky983/komponent/generate.kt
            
            @file:Suppress("PackageDirectoryMismatch")
            
            package me.sparky983.komponent
    
            import kotlinx.browser.document
            import org.w3c.dom.events.*
            import org.w3c.dom.*
            
            private typealias EventHandler<E> = (E) -> Unit
            
            private typealias Attributes = AttributesBuilder.() -> Unit

            private fun <T: Element> Html.tag(
                domNode: T,
                attributes: Map<String, Signal<String?>>,
                dataAttributes: Attributes?,
                events: Map<String, EventHandler<*>?>,
                children: Children
            ): T {
                val tag = Tag(domNode, contexts)
                for ((attribute, signal) in attributes) {
                    val subscription = signal.subscribe {
                        if (it == null) {
                            domNode.removeAttribute(attribute)
                        } else {
                            domNode.setAttribute(attribute, it)
                        }
                    }
                    tag.onMount { subscription.canceled = false }
                    tag.onUnmount { subscription.canceled = true }
                }
                if (dataAttributes != null) {
                    for ((attribute, value) in AttributesBuilder().apply(dataAttributes).attributes) {
                        val subscription = value.subscribe {
                            if (it != null) {
                                domNode.setAttribute("data-${'$'}attribute", it)
                            } else {
                                domNode.removeAttribute("data-${'$'}attribute")
                            }
                        }
                        tag.onMount { subscription.canceled = false }
                        tag.onUnmount { subscription.canceled = true }
                    }
                }
                for ((event, handler) in events) {
                    if (handler != null) {
                        domNode.addEventListener(
                            event,
                            handler.unsafeCast<(Event) -> Unit>()
                        )
                    }
                }
                tag.children()
                emit(tag)
                return domNode
            }
            """.trimIndent()
        )

        val global = tagsDefinition.global

        for ((name, tag) in tagsDefinition.tags) {
            append("\n\n")
            append("""@Suppress("unused")""")
            append("\n")
            append("public fun Html.${name}(")

            val attributes = global.attributes + tag.attributes

            for ((name, attribute) in attributes) {
                val (parameter, type, isRequired) = attribute

                append("\n    ${parameter ?: name}: Signal<$type>")
                if (!isRequired) {
                    append("? = null")
                }
                append(",")
            }

            val events = global.events + tag.events

            for ((name, event) in events) {
                append("\n")
                append("    ")
                append(event.parameter(name))
                append(": EventHandler<${event.type}>? = null,")
            }

            append("\n    data: Attributes? = null,")

            if (!tag.void) {
                append("\n    children: Children")
            }

            append("\n")
            append("): ${tag.type} {\n")
            append("    return tag(\n")
            append("        ")
            if (tag.ns != null) {
                append("document.createElementNS(\"${tag.ns}\", ")
            } else {
                append("document.createElement(")
            }
            append("\"$name\") as ${tag.type},\n")
            append("        buildMap {")

            for ((name, attribute) in attributes) {
                val type = attribute.type
                val parameter = attribute.parameter ?: name

                append("\n")
                append("            ")

                if (attribute.required) {
                    append("put(\"$name\", ")
                } else {
                    append(parameter)
                    append("?.let { put(\"$name\", ")
                }

                append(parameter)

                when (type) {
                    "Boolean" -> {
                        append(" { if (it) \"\" else null }")
                    }

                    else -> {
                        if (type != "String") {
                            append("(Any::toString)")
                        }
                    }
                }

                append(")")

                if (!attribute.required) {
                    append(" }")
                }
            }

            append("\n")
            append("        },\n")
            append("        data,\n")
            append("        mapOf(")

            for ((name, event) in events) {
                append("\n")
                append("            \"$name\" to ${event.parameter(name)}, ")
            }

            append("\n")
            append("        )")

            if (!tag.void) {
                append(",\n")
                append("        children = children")
                append("\n")
                append("    )")
            } else {
                append("\n    ) {}")
            }

            append("\n}")
        }
    }

    FileWriter(tagsApi).use {
        // Technically this is inefficient
        it.append(file.replace("\n", System.lineSeparator()))
    }
}